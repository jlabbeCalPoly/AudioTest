package com.zybooks.audiotest

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import androidx.compose.ui.graphics.Path
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.coroutines.coroutineContext
import kotlin.math.max
import kotlin.math.min

class GraphicalViewModel : ViewModel() {
    // include ? after Job type since graphicalJob may also be null
    private var graphicalJob : Job? = null

    // is new audio data being streamed in or not
    var isRunning by mutableStateOf(false)
        private set

    // path generated by the audioData
    var path: Path? by mutableStateOf(null)
        private set
    var width: Float by mutableFloatStateOf(0f)
    var height: Float by mutableFloatStateOf(0f)

    fun setGraphSize(width: Float, height: Float) {
        this.width = width
        this.height = height
    }

    @SuppressLint("MissingPermission")
    fun startGraphical() {
        // debounce if the graphical display is already running
        if(!isRunning) {
            isRunning = true

            val buffer = AudioRecord.getMinBufferSize(44100, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT)
            val recorder = AudioRecord( MediaRecorder.AudioSource.MIC,
                44100,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                buffer
            )
            val shortArray = ShortArray(buffer)

            fun smoothData(data: ShortArray, readSize: Int): List<Float> {
                val chunkSize = readSize/200
                val smoothedData = data.toList().chunked(chunkSize).map{
                    chunk ->
                        val filtered = chunk.filter {it > 5}
                        if(filtered.isNotEmpty()) {
                            filtered.average().toFloat()
                        } else {
                            0f
                        }
                }

                smoothedData.mapIndexed {
                    index, _ -> smoothedData.slice(index until min(index+chunkSize, smoothedData.size)).average()
                }
                return smoothedData
            }

            fun buildPath(readSize: Int) {
                var xOffset = 0f
                val smoothedData = smoothData(shortArray, readSize)
                val lineWidth = width/smoothedData.size
                val lineHeight = height/2

                path = Path().apply {
                    reset()
                    moveTo(0f, height/2)
                    for (data in smoothedData) {
                        val yOffset = lineHeight + data
                        xOffset += lineWidth

                        lineTo(xOffset, yOffset)
                        moveTo(xOffset, yOffset)
                    }
                    close()
                }
            }

            fun readData(): Int? {
                var readSize : Int? = null
                try {
                    readSize = recorder.read(shortArray, 0, buffer)
                } catch(e: Exception) {
                    e.message?.let { Log.e("Error:", it) }
                    return null
                }
                return readSize
            }

            graphicalJob = viewModelScope.launch {
                withContext(Dispatchers.IO) {
                    recorder.startRecording()
                    try {
                        while(isRunning) {
                            val readData = readData()
                            if (readData != null && readData > 0) {
                                Log.d("Reading", ""+readData)
                                buildPath(readData)
                            }
                        }
                    } catch(e: Exception) {
                        e.message?.let { Log.e("Error:", it)}
                    } finally {
                        recorder.stop()
                        recorder.release()
                    }
                }
            }
        }
    }

    fun cancelGraphical() {
        if(isRunning) {
            graphicalJob?.cancel()
            isRunning = false
        }
    }
}