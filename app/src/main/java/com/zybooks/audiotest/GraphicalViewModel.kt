package com.zybooks.audiotest

import android.annotation.SuppressLint
import androidx.compose.ui.graphics.Path
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min

class GraphicalViewModel : ViewModel() {
    // include ? after Job type since graphicalJob may also be null
    private var graphicalJob : Job? = null

    // is new audio data being streamed in or not
    var isRunning by mutableStateOf(false)
        private set
    var onStart by mutableStateOf(false)
        private set

    // path generated by the audioData
    var path: Path? by mutableStateOf(Path())
        private set
    var smoothedData: List<Float>? by mutableStateOf(null)
    var width: Float by mutableFloatStateOf(0f)
    var height: Float by mutableFloatStateOf(0f)
    var prevReadSize: Int by mutableIntStateOf(0)

    // Y-axis range value for dynamic scaling
    var graphicalAmplitude: Float = 1f

    // Number of divisions for Y-axis labels (excluding zero)
    val yAxisDivisions = 4
    // Stores the values for the Y-axis labels
    var yAxisLabels: List<Float>? by mutableStateOf(null)
        private set

    fun setGraphSize(width: Float, height: Float) {
        this.width = width
        this.height = height
        // buildPath() will already run if new data is being read in, so
        // no need to recompute the path since it'll already be displayed
        if(!isRunning && onStart) {
            onStart = false
            resizeGraph()
        }
    }

    // This is called each time onStart is invoked in MainActivity.kt
    // Allows the graph to resize properly in the event of a config change
    // and not end up in an infinite loop
    fun setOnStart() {
        onStart = true
    }

    // This function is only to be ran if the user prompts a
    // configuration change while the data acquisition is paused
    fun resizeGraph() {
        if (smoothedData != null) {
            Log.d("Resize", "Resize")
            val currentData = smoothedData?.toList() ?: return

            // Find the max amplitude in the smoothed data
            val dataMax = currentData.maxOrNull() ?: 1f
            val dataMin = currentData.minOrNull() ?: -1f

            val currentMaxAmplitude = max(dataMax, 1f)
            val currentMinAmplitude = min(dataMin, -1f)

            val bound = max(abs(dataMax), abs(dataMin))
            graphicalAmplitude = max(abs(currentMaxAmplitude), abs(currentMinAmplitude))

            var xOffset = 0f
            val lineWidth = width / currentData.size

            // update the YAxis labels, will automatically recompose in GraphicalScreen.kt
            getYAxisLabelValues()

            path = Path().apply {
                reset()
                moveTo(0f, height / 2) // Start from the middle

                for (data in currentData) {
                    val offset = data/bound * height/2
                    val yOffset = height/2 + offset
                    xOffset += lineWidth

                    lineTo(xOffset, yOffset)
                }
            }
        }
    }

    @SuppressLint("MissingPermission")
    fun startGraphical() {
        // Microphone/Recording permissions are checked in GraphicalScreen.kt
        // Debounce if the graphical display is already running
        if(!isRunning) {
            isRunning = true

            // Set up the audio recorder
            // AudioRecord is being used over MediaRecord since
            // it's better for real-time audio processing
            val buffer = AudioRecord.getMinBufferSize(44100, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT)
            val recorder = AudioRecord( MediaRecorder.AudioSource.MIC,
                44100,                 // 44100 samples of audio data per second (40,000-48,000 is best practice for high-quality voice recording)
                AudioFormat.CHANNEL_IN_MONO,         // one audio channel, meaning all audio data captured is combined into one signal
                AudioFormat.ENCODING_PCM_16BIT,      // Frequencies are stored as shorts, meaning there are ~65000 possible values that can be returned (This is signed, so negative values are also possible)
                buffer                               // The size of the buffer that can be filled with audio data
            )
            val shortArray = ShortArray(buffer)

            // Read data from the microphone into the shortArray
            // return the number of values read (Normally ~2800)
            fun readData(): Int? {
                var readSize : Int? = null
                try {
                    readSize = recorder.read(shortArray, 0, buffer)
                } catch(e: Exception) {
                    e.message?.let { Log.e("Error:", it) }
                    return null
                }
                prevReadSize = readSize
                return readSize
            }

            // Currently, each read results in ~2800 different values in the data buffer
            // Way to many to display in a useful way in our graph
            // Instead, group nearby data and average them out
            fun smoothData(data: ShortArray, readSize: Int): List<Float> {
                val chunkSize = readSize / 150
                val smoothedData = mutableListOf<Float>()
                data.toList().chunked(chunkSize).forEach { chunk ->
                    smoothedData.add(chunk.average().toFloat())
                }

                return smoothedData
            }

            // Build a path to be displayed in a graphical form using the
            // smoothed data and known width/height/bounds
            fun buildPath(readSize: Int) {
                var xOffset = 0f
                val smoothedData = smoothData(shortArray, readSize)

                // Find the max amplitude in the smoothed data
                val dataMax = smoothedData.maxOrNull() ?: 1f
                val dataMin = smoothedData.minOrNull() ?: -1f

                // determine the min/max of the data, used to bound all of the graphical data properly
                val currentMaxAmplitude = max(dataMax, 1f)
                val currentMinAmplitude = min(dataMin, -1f)

                val bound = max(abs(dataMax), abs(dataMin))
                graphicalAmplitude = max(abs(currentMaxAmplitude), abs(currentMinAmplitude))

                // Calculate scale to fit in view
                val lineWidth = width / smoothedData.size

                // update the YAxis labels, will automatically recompose in GraphicalScreen.kt
                getYAxisLabelValues()
                // save the smoothedData, this is only actually used when a
                // reconfiguration occurs while the data acquisition is paused
                this.smoothedData = smoothedData

                // reset the original path, using the new data to
                path = path!!.apply {
                    reset()
                    moveTo(0f, height / 2) // Start from the middle

                    for (data in smoothedData) {
                        // data/bound represents the height percentage relative to the maximum,
                        // therefore making sure all paths are within the bounds of the graph
                        val offset = data/bound * height/2
                        val yOffset = height/2 + offset
                        xOffset += lineWidth

                        lineTo(xOffset, yOffset)
                    }
                }
            }

            graphicalJob = viewModelScope.launch {
                withContext(Dispatchers.IO) {
                    recorder.startRecording()
                    try {
                        while(isRunning) {
                            val readData = readData()
                            if (readData != null && readData > 0) {
                                buildPath(readData)
                            }
                        }
                    } catch(e: Exception) {
                        e.message?.let { Log.e("Error:", it)}
                    } finally {
                        recorder.stop()
                        recorder.release()
                    }
                }
            }
        }
    }

    fun cancelGraphical() {
        if(isRunning) {
            graphicalJob?.cancel()
            isRunning = false
        }
    }

    // Helper function to get Y-axis label values
    fun getYAxisLabelValues() {
        val max = graphicalAmplitude
        val range = max * 2
        val step = range / yAxisDivisions
        val labels = mutableListOf<Float>()
        for (i in 0..yAxisDivisions) {
            labels.add(max - (step * i))
        }
        yAxisLabels = labels
    }

    // onCleared is called whenever the viewModel is no longer in use
    // prevent memory leaks
    @Override
    override fun onCleared() {
        super.onCleared()
        graphicalJob?.cancel()
    }
}