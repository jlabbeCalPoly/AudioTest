package com.zybooks.audiotest

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import androidx.compose.ui.graphics.Path
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import androidx.compose.animation.core.animateOffsetAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.coroutines.coroutineContext
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min

class GraphicalViewModel : ViewModel() {
    init {
        Log.d("GraphicalViewModel", "GraphicalViewModel created")
    }
    // include ? after Job type since graphicalJob may also be null
    private var graphicalJob : Job? = null

    // is new audio data being streamed in or not
    var isRunning by mutableStateOf(false)
        private set

    // path generated by the audioData
    var path: Path? by mutableStateOf(Path())
        private set
    var smoothedData: List<Float>? by mutableStateOf(null)
    var width: Float by mutableFloatStateOf(0f)
    var height: Float by mutableFloatStateOf(0f)
    var prevReadSize: Int by mutableIntStateOf(0)

    // Y-axis range value for dynamic scaling
    var graphicalAmplitude: Float = 1f

    // Number of divisions for Y-axis labels (excluding zero)
    val yAxisDivisions = 4
    // Stores the values for the Y-axis labels
    var yAxisLabels: List<Float>? by mutableStateOf(null)
        private set

    fun setGraphSize(width: Float, height: Float) {
        this.width = width
        this.height = height
        // buildPath() will already run if new data is being read in,
        // no need to recompute it
        if(!isRunning) {
            resizeGraph()
        }
    }

    fun resizeGraph() {
        if (smoothedData != null) {
            val currentData = smoothedData!!

            // Find the max amplitude in the smoothed data
            val dataMax = currentData.maxOrNull() ?: 1f
            val dataMin = currentData.minOrNull() ?: -1f

            // Update the max and min amplitudes with smoothing
            // Use a damping factor to gradually adjust the range (prevents too rapid changes)
            //val dampingFactor = 0.7f
            val currentMaxAmplitude = max(dataMax, 1f)
            val currentMinAmplitude = min(dataMin, -1f)

            val bound = max(abs(dataMax), abs(dataMin))
            graphicalAmplitude = max(abs(currentMaxAmplitude), abs(currentMinAmplitude))

            var xOffset = 0f
            val lineWidth = width / currentData.size

            // update the YAxis labels, will automatically recompose in GraphicalScreen.kt
            getYAxisLabelValues()

            path = path!!.apply {
                reset()
                moveTo(0f, height / 2) // Start from the middle

                for (data in currentData) {
                    // Scale relative to the dynamic range
                    val offset = data/bound * height/2
                    val yOffset = height/2 + offset
                    xOffset += lineWidth

                    lineTo(xOffset, yOffset)
                }
            }
        }
    }

    @SuppressLint("MissingPermission")
    fun startGraphical() {
        // debounce if the graphical display is already running
        if(!isRunning) {
            isRunning = true

            val buffer = AudioRecord.getMinBufferSize(44100, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT)
            val recorder = AudioRecord( MediaRecorder.AudioSource.MIC,
                44100,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                buffer
            )
            val shortArray = ShortArray(buffer)

            fun readData(): Int? {
                var readSize : Int? = null
                try {
                    readSize = recorder.read(shortArray, 0, buffer)
                } catch(e: Exception) {
                    e.message?.let { Log.e("Error:", it) }
                    return null
                }
                prevReadSize = readSize
                return readSize
            }

            fun smoothData(data: ShortArray, readSize: Int): List<Float> {
                val chunkSize = readSize / 150
                val smoothedData = mutableListOf<Float>()
                data.toList().chunked(chunkSize).forEach { chunk ->
                    smoothedData.add(chunk.average().toFloat())
                }

                return smoothedData
            }

            fun buildPath(readSize: Int) {
                var xOffset = 0f
                val smoothedData = smoothData(shortArray, readSize)

                // Find the max amplitude in the smoothed data
                val dataMax = smoothedData.maxOrNull() ?: 1f
                val dataMin = smoothedData.minOrNull() ?: -1f

                // Update the max and min amplitudes with smoothing
                // Use a damping factor to gradually adjust the range (prevents too rapid changes)
                //val dampingFactor = 0.7f
                val currentMaxAmplitude = max(dataMax, 1f)
                val currentMinAmplitude = min(dataMin, -1f)

                val bound = max(abs(dataMax), abs(dataMin))
                graphicalAmplitude = max(abs(currentMaxAmplitude), abs(currentMinAmplitude))

                // Calculate scale to fit in view
                //val amplitudeScale = height / range
                val lineWidth = width / smoothedData.size

                // update the YAxis labels, will automatically recompose in GraphicalScreen.kt
                getYAxisLabelValues()
                this.smoothedData = smoothedData

                path = path!!.apply {
                    reset()
                    moveTo(0f, height / 2) // Start from the middle

                    for (data in smoothedData) {
                        // Scale relative to the dynamic range
                        val offset = data/bound * height/2
                        val yOffset = height/2 + offset
                        xOffset += lineWidth

                        lineTo(xOffset, yOffset)
                    }
                }
            }

            graphicalJob = viewModelScope.launch {
                withContext(Dispatchers.IO) {
                    recorder.startRecording()
                    try {
                        while(isRunning) {
                            val readData = readData()
                            if (readData != null && readData > 0) {
                                buildPath(readData)
                            }
                        }
                    } catch(e: Exception) {
                        e.message?.let { Log.e("Error:", it)}
                    } finally {
                        recorder.stop()
                        recorder.release()
                    }
                }
            }
        }
    }

    fun cancelGraphical() {
        if(isRunning) {
            graphicalJob?.cancel()
            isRunning = false
        }
    }

    // Helper function to get Y-axis label values
    fun getYAxisLabelValues() {
        val max = graphicalAmplitude
        val range = max * 2
        val step = range / yAxisDivisions
        val labels = mutableListOf<Float>()
        for (i in 0..yAxisDivisions) {
            labels.add(max - (step * i))
        }
        yAxisLabels = labels
    }
}