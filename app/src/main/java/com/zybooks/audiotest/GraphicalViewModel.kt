package com.zybooks.audiotest

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import androidx.compose.ui.graphics.Path
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import androidx.compose.animation.core.animateOffsetAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.coroutines.coroutineContext
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min

class GraphicalViewModel : ViewModel() {
    // include ? after Job type since graphicalJob may also be null
    private var graphicalJob : Job? = null

    // is new audio data being streamed in or not
    var isRunning by mutableStateOf(false)
        private set

    // path generated by the audioData
    var path: Path? by mutableStateOf(Path())
        private set
    var width: Float by mutableFloatStateOf(0f)
    var height: Float by mutableFloatStateOf(0f)

    // Y-axis range value for dynamic scaling
    var graphicalAmplitude: Float = 1f

    // Number of divisions for Y-axis labels (excluding zero)
    val yAxisDivisions = 4
    // Stores the values for the Y-axis labels
    var yAxisLabels: List<Float>? by mutableStateOf(null)
        private set

    fun setGraphSize(width: Float, height: Float) {
        this.width = width
        this.height = height
    }

    @SuppressLint("MissingPermission")
    fun startGraphical() {
        // debounce if the graphical display is already running
        if(!isRunning) {
            isRunning = true

            val buffer = AudioRecord.getMinBufferSize(44100, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT)
            val recorder = AudioRecord( MediaRecorder.AudioSource.MIC,
                44100,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                buffer
            )
            val shortArray = ShortArray(buffer)

            fun smoothData(data: ShortArray, readSize: Int): List<Float> {
                val chunkSize = readSize / 150
                val smoothedData = mutableListOf<Float>()
                   data.toList().chunked(chunkSize).forEach { chunk ->
                   smoothedData.add(chunk.average().toFloat())
                }

                // Apply moving average to further smooth data
                //val windowSize = 5  // Number of points to
                //val max = smoothedData.max()
                //val min = smoothedData.min()
                //val avg = (max - min)/2
                //var counter = 0

                return smoothedData
            }

            fun buildPath(readSize: Int) {
                var xOffset = 0f
                val smoothedData = smoothData(shortArray, readSize)

                // Find the max amplitude in the smoothed data
                val dataMax = smoothedData.maxOrNull() ?: 1f
                val dataMin = smoothedData.minOrNull() ?: -1f

                // Update the max and min amplitudes with smoothing
                // Use a damping factor to gradually adjust the range (prevents too rapid changes)
                //val dampingFactor = 0.7f
                val currentMaxAmplitude = max(dataMax, 1f)
                val currentMinAmplitude = min(dataMin, -1f)

                val bound = max(abs(dataMax), abs(dataMin))
                graphicalAmplitude = max(abs(currentMaxAmplitude), abs(currentMinAmplitude))

                // Calculate scale to fit in view
                //val amplitudeScale = height / range
                val lineWidth = width / smoothedData.size

                // update the YAxis labels, will automatically recompose in GraphicalScreen.kt
                getYAxisLabelValues()

                path = path!!.apply {
                    reset()
                    moveTo(0f, height / 2) // Start from the middle

                    for (data in smoothedData) {
                        // Scale relative to the dynamic range
                        val offset = data/bound * height/2
                        val yOffset = height/2 + offset
                        xOffset += lineWidth

                        lineTo(xOffset, yOffset)
                    }
                }
            }

            fun readData(): Int? {
                var readSize : Int? = null
                try {
                    readSize = recorder.read(shortArray, 0, buffer)
                } catch(e: Exception) {
                    e.message?.let { Log.e("Error:", it) }
                    return null
                }
                return readSize
            }

            graphicalJob = viewModelScope.launch {
                withContext(Dispatchers.IO) {
                    recorder.startRecording()
                    try {
                        while(isRunning) {
                            val readData = readData()
                            if (readData != null && readData > 0) {
                                buildPath(readData)
                            }
                        }
                    } catch(e: Exception) {
                        e.message?.let { Log.e("Error:", it)}
                    } finally {
                        recorder.stop()
                        recorder.release()
                    }
                }
            }
        }
    }

    fun cancelGraphical() {
        if(isRunning) {
            graphicalJob?.cancel()
            isRunning = false
        }
    }

    // Helper function to get Y-axis label values
    fun getYAxisLabelValues() {
        val max = graphicalAmplitude
        val range = max * 2
        val step = range / yAxisDivisions
        val labels = mutableListOf<Float>()
        for (i in 0..yAxisDivisions) {
            labels.add(max - (step * i))
        }
        yAxisLabels = labels
    }
}